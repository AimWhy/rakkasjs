---
title: "Rakkas 0.6: Streaming SSR with Suspense and useServerSideQuery"
date: 2022-07-04
---

{/* TODO: Fix date */}

💃 [Rakkas](https://github.com/rakkasjs/rakkasjs), the lightning-fast React framework powered by [Vite](https://vitejs.dev), has just released version 0.6.0. More than a year on since the first commit, this is the largest and least backwards compatible update so far. The reason is we decided to go all in with the new React 18 features with this release. Gone are the page-centric data fetching functions that ran before the page was rendered (“fetch-then-render”). Instead, we've come up with a novel data fetching custom hook that can be used in any component (“render-as-you-fetch“).

If you're familiar with Next.js, you know how cool `getServerSideProps` is. With it, you can put, say, your database access code right next to your page component without worrying about designing and maintaining a REST/GraphQL/RPC/whatever API. Next.js cleverly strips this function and its imports from the client bundle. During SSR, it's called directly. On the client, Next sends a request to the server instead of calling the function.

We believe we've one-upped the ease of use of this data fetching method. Enter `useServerSideQuery`:

```jsx
import db from "./my-db-access-lib";

export default function UserCard(props) {
	const userName = props.userName;

	const userQuery = useServerSideQuery(() => {
		if (typeof userName !== "string") {
			throw new Error("Invalid request");
		}

		return db.user.findOne(userName);
	});

	return (
		<div class="card">
			<img src={userQuery.data.image} />
			<caption>{userQuery.data.fullName}</caption>
		</div>
	);
}
```

This is _not_ a page, just an ordinary React component. In Rakkas 0.6 pages aren't very special in terms of data fetching anymore. Just like `getServerSideProps`, the function passed to `useServerSideQuery` (`useSSQ` for hort) always runs on the server: On the client, a request is sent to the server instead of calling the function directly. Rakkas performs a code transform similar to Next's to strip the function and its imports from the client bundle.

`useSSQ`'s return type is inferred, so, if you're using TypeScript, you get IDE completion just like you would with a local function call. Another nice feature is that, unlike other similar data fetching hooks, `useSSQ` doesn't return loading or error states. Those are handled higher up in the component tree, with Suspense fallbacks and error boundaries respectively. This way, your component code stays clean and focused.

Paired with its sibling `useServerSideMutation`, `useSSQ` lets you write code as if the server-client barrier didn't exist. This is almost too good to be true, surely there must be some caveats to this. And there are indeed...

### Caveats

`useSSQ` “captures” the variables from the surrounding scope. In the above example, when the code runs on the client, `userName` is captured, serialized, and sent to the server. The server then runs the function and the result is serialized and sent back to the client.

Server-side code is server-side code no matter where it resides in the source code: _You have to **validate** everything that comes from the client_. But with such an easy to use hook, it may not be easy to spot what was captured from the surrounding scope and, therefore, comes from the client, necessitating validation. In this example, a simple type-check is all that's needed. In more complex cases, you will eventually need a validation library, like in any backend.

Also, serialization obviously brings some limitations. Rakkas uses [`@brillout/json-s`](https://github.com/brillout/json-s) to serialize the captured variables and [`devalue`](https://github.com/Rich-Harris/devalue) to serialize the return value. They both support `Date`, `undefined`, `Set`, `Map`, `BigInt`, `RegExp`, `NaN`, and `Infinity` in addition to the standard JSON-serializable types. `devalue` also supports repeated and cyclic references. Captured values and the return value must be serializable with the respective libraries. In particular, functions, arbitrary class instances, DOM elements etc. cannot be serialized by these libraries.

Another thing to consider in this example is that instead of accessing `props.userName` from the server-side function, we extract `userName` and only access that. Doing the former would capture the whole `props` object which may contain unserializable, or at least irrelevant data. This is not just to save a few bytes: By default, Rakkas uses the values of the captured variables as part of the cache key, unintentionally capturing unrelated data may cause unnecessary refetches.

We feel none these caveats is a showstopper. We're planning to create linter rules to help the programmer spot potential problems. With the help of a such tool, we think the best practices of using `useSSQ` are not harder to follow than React's own Rules of Hooks.

### Circumventing CORS restrictions

One practical application of `useSSQ` that may not be immediately obvious is circumventing CORS restrictions when calling third-party APIs:

```ts
const result = useServerSideQuery(() =>
	fetch("https://some.cors.restricted.api.example.com").then((res) =>
		res.json(),
	),
);
```

This works because the `fetch` call inside `useServerSideQuery` runs on the server-side (Rakkas makes `node-fetch` globally available on Node-based deployment targets) and, as such, is not affected by CORS restrictions. In effect, it creates an ad-hoc CORS proxy.

### Fetching from other APIs

Rakkas 0.6 also comes with `useQuery` and `useMutation` hooks that implement a Suspense-only subset of the [react-query](https://react-query.tanstack.com) API. In fact, `useServerSideQuery` and `useServerSideMutation` are wrappers around `useQuery` and `useMutation` and use the lower level `runServerSideQuery` and `runServerSideMutation` functions.

Of course API routes are still available to allow you to implement REST, GraphQL, RPC etc. endpoints that you can access via `useQuery` and `useMutation` hooks if you prefer the traditional data fetching methods.

### Preloading data

Even though we said that in Rakkas 0.6 pages and layouts are not very special in terms of data fetching anymore, you can still have a `preload` function to start fetching early to avoid late discovery of data dependencies and waterfalls. `preload` also provides a way to inject SEO-critical title and meta tags into the page even when streaming.

## Streaming SSR

Rakkas 0.6 brings streaming SSR support. It sends chunks of a page's HTML as soon as they are available. This way, the user starts seeing meaningful content as soon as possible instead of waiting in front of a blank screen. Streaming SSR integrates seamlessly with Suspense and the data fetching methods described above.

If you're worried about streaming SSR interfering with SEO, you'll be relieved to know that Rakkas also implements [dynamic rendering](https://huckabuy.com/technical-seo/dynamic-rendering): It sends search bots fully rendered pages with correct status codes and HTTP headers while streaming HTML to normal browsers. In any case, you can opt out of streaming on a global or per-page basis without giving up Suspense-based data fetching.

## HatTip

The new Rakkas version is built on [HatTip](https://github.com/hattipjs/hattip), an HTTP server library that abstracts away the differences between various JavaScript runtimes. Rakkas already ran on Node, Vercel Serverless Functions, Netlify Functions, and Cloudflare Workers. HatTip integration adds support for Deno (including Deno deploy), Vercel Edge Functions, and Netlify Edge Functions. The new request/response API use standard `Request` and `Response` objects on all platforms.

## Other features

If this is the first time you hear of Rakkas, it has other cool features like lightning-fast development server (courtesy of Vite), truly localizable URLs, nested layouts, out-of-the-box MDX support, and more.

Rakkas uses experimental and/or beta features of React and Vite. As such, expect breaking changes until we hit 1.0. But [go ahead and give it a try](https://stackblitz.com/edit/rakkas-demo-ts?file=src%2Fpages%2Fpage.tsx) and share your thoughts. [Star us on Github](https://github.com/rakkasjs/rakkasjs/stargazers) and [talk about Rakkas](https://twitter.com/intent/tweet?text=I%20gave%20%23RakkasJS%20a%20try!&url=https%3A%2F%2Fgithub.com%2Frakkasjs%2Frakkasjs) if you like what you see. Also feel free to [follow me on Twitter](https://twitter.com/cyco130) for updates.

If you have any questions, problems, or suggestions [open a Github issue](https://github.com/rakkasjs/rakkasjs/issues/new). If you want to [contribute](https://github.com/rakkasjs/rakkasjs/blob/main/CONTRIBUTING.md), fork and send a pull request. Check out the [open issues](https://github.com/rakkasjs/rakkasjs/issues) to see how you can help. **All feedback is welcome**, positive or negative.
