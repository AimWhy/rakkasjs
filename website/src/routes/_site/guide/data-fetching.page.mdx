import { SampleViewer } from "./SampleViewer";

# Data fetching

> React 18 brings support for "Suspense for data fetching" with streaming SSR support. Since version 0.6, Rakkas's data fetching is implemented on top of this feature.

`useServerSideQuery` (or `useSSQ` for short) from the `rakkasjs` package is the primary way to fetch data from the server. It is similar to `getServerSideProps` in **Next.js** but it can be used in _any_ React component, not just pages. It also provides type inference.

`useServerSideQuery` takes a function as its first argument. This function always runs on the server: During server-side rendering, it runs directly. On the client, Rakkas converts the function call into an HTTP request and the server handles the request by calling the function. Rakkas strips everything that is only used in the server-side function from the client bundle, so you're free to use server-only APIs, like databases, filesystem etc.

import useSSQExample from "$examples/use-ssq/[pokemon].page.tsx?sample";

<SampleViewer
	url="/examples/use-ssq/pikachu"
	code={useSSQExample}
	height="35em"
/>

## Caveats

`useServerSideQuery` is very powerful but there are a few important points to keep in mind:

First of all, `useServerSideQuery` is not a normal function. It's more like a macro that is processed by Rakkas's code transforms. The function argument must be defined inline, passing functions defined elsewhere (`useSSQ(someFunc)`) will not work.

When it runs on the client, variables from the surrounding scope that you use in the server-side function are captured, serialized, and sent to the server. Since anyone can send any request to the server, **you have to validate everything** that comes from the surrounding scope. In the example above, we make sure that the `pokemon` variable is indeed a string. More complex data will require more complex validation. In essence, each use of `useServerSideQuery` creates an API endpoint so you should treat the server-side function as such and validate all user input.

> TODO: We're planning to create an ESLint rule to enforce safe practices for useServerSideQuery.

<!-- TODO: Add a GitHub issue for safe useSSQ rule -->

Also note that instead of referencing `props.params.pokemon`, which would cause the whole `props` object to be captured and serialized, we destructure it and reference only the part we're actually interested in. This is not just to save a few bytes: By default, Rakkas uses the values of the captured variables as part of the cache key, unintentionally capturing irrelevant data may cause unnecessary refetches.

Rakkas uses [`@brillout/json-s`](https://github.com/brillout/json-s) to serialize the captured variables and [devalue](https://github.com/Rich-Harris/devalue) to serialize the return value. They both support `Date`, `undefined`, `Set`, `Map`, `BigInt`, `RegExp`, `NaN`, and `Infinity` in addition to the standard JSON-serializable types. `devalue` also supports repeated and cyclic references. Captured values and the return value must be serializable with the respective libraries. In particular, functions, arbitrary class instances, DOM elements etc. cannot be serialized properly.

## Circumventing CORS restrictions

`useSSQ` provides a very simple way to circumvent CORS restrictions when calling third-party APIs.

```ts
const result = useServerSideQuery(() =>
	fetch("https://some.cors.restricted.api.example.com").then((res) =>
		res.json(),
	),
);
```

This works because the `fetch` call inside `useServerSideQuery` runs on the server-side which is not affected by CORS restrictions. In effect, it creates an ad-hoc CORS proxy.
