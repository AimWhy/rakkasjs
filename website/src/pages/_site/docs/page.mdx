import { Link } from "rakkasjs";
import { SampleViewer } from "./SampleViewer";
import { Helmet } from "rakkasjs/helmet";

<Helmet title="Documentation - Rakkas" />

# Rakkas Documentation

## What is Rakkas?

> Elevator pitch: Next.js on Vite or Svelte Kit for React.

**Rakkas** aims to be a [React](https://reactjs.org) framework powered by [Vite](https://vitejs.dev), with a developer experience inspired by [Next.js](https://nextjs.org) and [Svelte Kit](https://kit.svelte.dev).

> **WARNING:** Rakkas is in early development. Do not use in production!

Rakkas stands on the shoulders of giants: React and Vite. They bring the following to the table:

- React:
  - Declarative coding style
  - Component-based architecture
  - Vast ecosystem and learning resources
- Vite:
  - Lightning fast development environment with Fast Refresh support
  - Automatic code splitting (including CSS)
  - Support for CSS modules and preprocessors

On top of all this awesomeness, Rakkas comes bundled with its own features:

- [x] Hassle free server-side rendering
- [x] Intuitive file system-based routing
  - [x] Dynamic routes
  - [x] Nested layouts
  - [x] Thematic grouping
- [x] SPA-style client-side router
- [x] Simple but effective data fetching system
  - [ ] Soon: Optional caching and "stale while revalidate" strategy
- [x] API routes to build API endpoints and middleware
- [ ] Soon: Support for serverless environments

## Getting started

The easiest way to try Rakkas out is to clone the TypeScript demo app:

```sh
# Create the project directory
mkdir my-app && cd my-app
# Clone the TypeScript demo app
npx degit rakkasjs/rakkasjs/starters/starter
# Install dependencies
npm install
```

Now `npm run dev` will start a development server, `npm run build` will build for production, and `npm start` will start the production server. You can clone `rakkasjs/rakkasjs/starters/starter-js` if you don't like TypeScript and prefer vanilla JavaScript but type definitions are self-documenting so it is easier to learn with the TypeScript demo.

> If you prefer a manual setup, you can install `rakkasjs`, `@rakkasjs/runner-node`, `react`, and `react-dom` as production dependencies, and `@rakkasjs/cli` as a dev dependency:

```sh
npm install --save rakkasjs @rakkasjs/runner-node react react-dom
npm install --save-dev @rakkasjs/cli
```

Then you can start a development server on `localhost:3000` with `npx rakkas dev`, build with `npx rakkas build`, and launch with `npx @rakkasjs/runner-node`.

## Pages

In Rakkas, a page is a React component default exported from a module in the `src/pages` directory, named `page.jsx` or anything that matches `*.page.jsx` (or `tsx`, or any other extension included in the `pageExtensions` configuration option).

Rakkas has a file system-based router. The file name determines the URL path. The rules are easy:

| Module name                | URL path      |
| -------------------------- | ------------- |
| `src/pages/page.jsx`       | `/`           |
| `src/pages/about.page.jsx` | `/about`      |
| `src/pages/about/page.jsx` | also `/about` |

Thanks to this specific naming convention (`(name.)?page.{extension}`), you don't have to resort to tricks like prepending an underscore to have your helper libraries and components next to your page components without fear of name collision.

A very simple Rakkas page would look like this:

import helloExample from "$examples/hello/page.tsx?sample";

<SampleViewer url="/examples/hello" code={helloExample} />

As you can see Rakkas comes bundled with [`react-helmet-async`](https://github.com/staylor/react-helmet-async#readme) to ensure version compatibility. It's a component for managing:

- Head tags: `title`, `base`, `meta`, `link`, `script`, `noscript`, and `style`.
- Attributes for `body`, `html` and `title` tags.

### Dynamic routes

Sometimes you need to encode parameters in the URL path like `/post/1`, `/post/2` etc. Dynamic routes like this are handled using `[square brackets]`. If you have a file named `/src/pages/profile/[userName].page.jsx`, for instance, and you visit `/profile/fatih`, your page component will receive `{ userName: "fatih"}` in `props.params` like in the example below (you can click on the links, you will stay on this page):

import paramsExample from "$examples/params/[userName].page.tsx?sample";

<SampleViewer url="/examples/params/Fatih" code={paramsExample} />

You can use more than one dynamic parameter like `/user/[userName]/posts/[postId]`. You can even put multiple parameters in a single path segment if you delimit them with `-` or `.`, like `/[name]-[surname]/contact-info`.

More specific routes have priority over more generic ones, so you can have both `/products/list` for a specific match and `/products/[productId]` as a catch-all route.

### Basic page props

Page components receive some props (TypeScript definitions are available as `PageProps` in the `rakkasjs` package):

| Prop     | Type                     | Description                               |
| -------- | ------------------------ | ----------------------------------------- |
| `url`    | `URL`                    | Current URL                               |
| `match`  | `string`                 | Matching path, i.e. "/profile/[userName]" |
| `params` | `Record<string, string>` | Path parameters macthing dynamic routes   |

> There are more but we'll cover them later.

### Navigation

Rakkas provieds a `Link` component (in the `rakkasjs` package) for client-side SPA-style navigation. It takes exactly the same props as the built-in `<a>` element but intercepts user's click to handle the navigation without reloading the page. `NavLink` component is similar but accepts `currentRouteClass` and `currentRouteStyle` that take effect when the `href` property matches the current URL. It is useful for styling the active item in a navigation menu.

Let's add client-side navigation to the previous example by replacing the `<a>` elements with `NavLink` and adding some inline styling for the active link. Notice how the page refreshes without a full reload:

import navlinkExample from "$examples/navlink/[userName].page.tsx?sample";

<SampleViewer url="/examples/navlink/Fatih" code={navlinkExample} />

For programmatic navigation, use the `navigate` function returned by the `useRakkas` custom hook from the `rakkasjs` package:

import navigateExample from "$examples/navigate/[userName].page.tsx?sample";

<SampleViewer url="/examples/navigate/Fatih" code={navigateExample} />

### Page transitions

The return value of `useRakkas` also has a `current` property. It's a URL object that contains the URL of the currently rendered page. You should always use this property insteaf of `window.location` because, a) `window` is not available during server-side rendering, and b) you'll get the wrong URL during page transitions: When the user clicks on a `Link`, the URL in the location bar of the browser changes immediately but the old page is still shown while the new one is loaded. This is similar how most browsers handle URL transitions natively.

The `next` property of the return value of `useRakkas`, if present, contains the URL that the app is transitioning into. You can test for its presence to render an animated loading bar for example. Also, the `NavLink` component accepts `nextRouteClass` and `nextRouteStyle` props that take effect during a page transition if the `href` property matches the URL that the app is transitioning into.

## Data loading

If you export a `load()` function from your page module, Rakkas will call this function before rendering your component. The `data` prop of the return value will be passed to the component as `props.data`. `load()` may be called on the server or on the client:

- It will be called during server-side rendering and its return value will be serialized (using [devalue](https://github.com/Rich-Harris/devalue)) and sent to the client. Therefore you should only use serializable values.
-

By default, Rakkas calls this function again when the URL params or the query string changes. You can force a reload by calling the `reload` prop:

import reloadExample from "$examples/reload/page.tsx?sample";

<SampleViewer url="/examples/reload" code={reloadExample} />

You can also use the `useReload` hook (passed to your page component) to reload the data in various circumstances:

import useReloadExample from "$examples/reload/use-reload.page.tsx?sample";

<SampleViewer url="/examples/reload/use-reload" code={useReloadExample} />

### fetch() function

`load()` can of course return a promise and is intended for data fetching. It is modeled after SvelteKit's `load()` function. It may run on the server or on the client. It is passed a fetch function that can be used both on the server and in the browser for issuing requests that include credentials. When run on the server-side, its return value is serialized (using [degit](https://github.com/Rich-Harris/degit)) and sent to the client. Therefore you may only use serializable values.

Used along with `useReload` hook and manual `reload`, it provides a simple but effective data fetching solution. Let's fetch connect to the free Pok√©api and create a simple pokemon stat app:

import fetchExample from "$examples/fetch/[pokemon].page.tsx?sample";

<SampleViewer url="/examples/fetch/pikachu" code={fetchExample} height="35em" />

By default, a page is reloaded when the URL params or the query string changes. You can customize this by exporting a `getCacheKey` function. It's return value can be anything that can be serialized into JSON. Then it is compared with the cached value to decide whether to reload the page. For example if you want to reload on query string changes only, you can use `export const getCacheKey({url}) => url.search`.

## Layouts

Very few web sites completely consist of independent pages. This site (which was made with Rakkas, of course - so meta!), for instance, has a header and footer that is common to documentation pages and the home page. Rakkas provides a nested layout system to handle this use case (and more). If you create a `layout.jsx` (or `tsx`, or any other extension included in the `pageExtensions` configuration option) that default exports a React component, pages in the same directory or deeper in the file system will be wrapped by the layout:

import layoutExampleLayout from "$examples/layout/layout.tsx?sample";
import layoutExampleHome from "$examples/layout/page.tsx?sample";
import layoutExampleAbout from "$examples/layout/about.page.tsx?sample";

<SampleViewer filename="pages/layout.tsx" code={layoutExampleLayout} />
<SampleViewer filename="pages/page.tsx" code={layoutExampleHome} />
<SampleViewer
	filename="pages/about.page.tsx"
	code={layoutExampleAbout}
	url="/examples/layout"
	height="12em"
/>

### Layout context

## Needs documentation

- CLI usage
- Configuration options
- Thematic grouping
- API routes
  - Endpoints
  - Middleware
  - Advanced middleware
- definePage / defineLayout
- Future plans
