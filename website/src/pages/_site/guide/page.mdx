import { Link } from "rakkasjs";
import { SampleViewer } from "./SampleViewer";
import { Helmet } from "react-helmet-async";

<Helmet title="Guide - Rakkas" />

# Rakkas Documentation

## What is Rakkas?

**Rakkas** is a web framework powered by [React](https://reactjs.org) and [Vite](https://vitejs.dev) that aims to have a developer experience similar to [Next.js](https://nextjs.org). Many of its features are also inspired by [Svelte Kit](https://kit.svelte.dev). Important features are:

- ⚡&nbsp; Lightning fast development
- 🖥️&nbsp; Hassle free server-side rendering
- ☸️&nbsp; SPA-style client-side navigation
- 📁&nbsp; Intuitive file system-based routing
- ⬇️&nbsp; Simple but effective data fetching system
- ⚙️&nbsp; API routes to build and organize your backend

We're also aiming to support **static site generation** and **deploying to serverless environments** before we hit 1.0.

> ### Is Rakkas right for you?
>
> - Although many features have been implemented, Rakkas is still in development. There _will_ be breaking changes until we hit 1.0. As such, it's not yet ready for production use. If you need a stable React framework try Next.js or [Gatsby](https://www.gatsbyjs.com/).
> - Rakkas doesn't aim compatibility with Next.js. Check out [Vitext](https://github.com/Aslemammad/vitext) if you want to port a Next.js application to Vite.
> - Rakkas is somewhat opinionated. If you need more flexibility try [vite-ssr-plugin](https://vite-plugin-ssr.com/).

## Getting started

> 🚀 You can now **try Rakkas online, right in your browser**!
>
> - [Rakkas **TypeScript** demo app on StackBlitz](https://stackblitz.com/edit/rakkas-demo-ts?file=src%2Fpages%2Fpage.tsx)
> - [Rakkas **JavaScript** demo app on StackBlitz](https://stackblitz.com/edit/rakkas-demo?file=src%2Fpages%2Fpage.jsx)

The easiest way to try Rakkas out on your computer is to use the project initializer:

```sh
# Create the project directory
mkdir my-app && cd my-app
# Scaffold the demo app: Follow the prompts for the rest
npx create-rakkas-app
```

`create-rakkas-app` project initializer comes with many features, all off which are optional but we strongly recommend enabling TypeScript on your first project because self-documenting type definitions allow for a smoother learning curve.

Demo project's source code comes with plenty of comments, you may not need this guide!

> 👷 If you prefer a manual setup, you can install `rakkasjs`, `@rakkasjs/runner-node`, `react`, `react-dom`, and `react-helmet-async` as production dependencies, and `@rakkasjs/cli` as a dev dependency:
>
> ```sh
> npm install --save rakkasjs @rakkasjs/runner-node react react-dom react-helmet-async
> npm install --save-dev @rakkasjs/cli
> ```
>
> Then you can start a development server on `localhost:3000` with `npx rakkas dev`, build with `npx rakkas build`, and launch with `npx @rakkasjs/runner-node`.

## Pages

In Rakkas, a page is a React component default exported from a module in the `src/pages` directory, named `page.jsx` or anything that matches `*.page.jsx` (or `tsx`, or any other extension included in the `pageExtensions` configuration option).

Rakkas has a file system-based router. The file name determines the URL path. The rules are easy:

| Module name                | URL path      |
| -------------------------- | ------------- |
| `src/pages/page.jsx`       | `/`           |
| `src/pages/about.page.jsx` | `/about`      |
| `src/pages/about/page.jsx` | also `/about` |

This specific naming convention (`(name.)?page.{extension}`) allows you to have your helper libraries and components next to your page components without resorting to prepending an underscore to prevent name collisions.

A very simple Rakkas page would look like this:

import helloExample from "$examples/hello/page.jsx?sample";

<SampleViewer
	filename="src/pages/page.jsx"
	code={helloExample}
	url="/examples/hello"
/>

As you see Rakkas relies on [`react-helmet-async`](https://github.com/staylor/react-helmet-async#readme) for managing head tags (`title`, `base`, `meta`, `link`, `script`, `noscript`, and `style`) and attributes for `body`, `html`, and `title` tags.

### Dynamic routes

Sometimes you need to encode parameters in the URL path like `/post/1`, `/post/2` etc. Dynamic routes like this are handled using `[square brackets]`. If you have a file named `/src/pages/profile/[userName].page.jsx`, for instance, and you visit `/profile/fatih`, your page component will receive `{ userName: "fatih" }` in `props.params` like in the example below (you can click on the links, they won't take you away from this page):

import paramsExample from "$examples/params/[userName].page.jsx?sample";

<SampleViewer
	filename="[userName].page.jsx"
	code={paramsExample}
	url="/examples/params/Fatih"
/>

You can use more than one dynamic parameter like `/user/[userName]/posts/[postId]`. You can even put multiple parameters in a single path segment if you delimit them with `-` or `.`, like `/user-[name]-[surname]/contact-info` (matches `/user-fatih-aygun/contact-info` with `params: { name: "fatih", surname: "aygun" }` for instance).

More specific routes have priority over more generic ones, so you can have both `/products/list` for a specific match and `/products/[productId]` as a catch-all route.

### Client-side navigation

Rakkas provieds a `Link` component (in the `rakkasjs` package) for SPA-style client-side navigation. It takes exactly the same props as the built-in `<a>` element but intercepts user's click to handle the navigation without reloading the page. `NavLink` component is similar but accepts `currentRouteClass` and `currentRouteStyle` to style them differently when the `href` property matches the current URL. It is useful for marking the active item in a navigation menu, for example.

Let's add client-side navigation to the previous example by replacing the `<a>` elements with `NavLink` and adding some inline styling for the active link. Notice how the page refreshes without a full reloadnow:

import navlinkExample from "$examples/navlink/[userName].page.jsx?sample";

<SampleViewer code={navlinkExample} url="/examples/navlink/Fatih" />

For programmatic navigation, use the `navigate` function exported from the `rakkasjs` package:

import navigateExample from "$examples/navigate/[userName].page.jsx?sample";

<SampleViewer url="/examples/navigate/Fatih" code={navigateExample} />

You can use `navigate(-1)` and `navigate(1)` two navigate one page back or one page forward respectively.

### Page transitions

The `useRouter` custom hook from the `rakkasjs` package has a `current` property. It's a URL object that contains the URL of the currently rendered page. You should always use this property insteaf of `window.location` because, a) `window` is not available during server-side rendering, and b) you'll get the wrong URL during page transitions: When the user clicks on a `Link`, the URL in the location bar of the browser changes immediately but the old page is still shown while the new one is being loaded.

The `next` property of the return value of `useRouter`, if present, contains the URL that the app is transitioning into. You can test for its presence to render some loading animation for example. Also, the `NavLink` component accepts `nextRouteClass` and `nextRouteStyle` props that take effect during a page transition if the `href` property matches the URL that the app is transitioning into.

## Layouts

Not many web sites consist of completely independent pages. This very site (which was made with Rakkas, of course - so meta!), for instance, has a header and footer that is common to the home page and the guide. Rakkas provides a nested layout system to handle this use case and more. If you create a file named `layout.jsx` (or `tsx`, or any other extension included in the `pageExtensions` configuration option) that default exports a React component, pages in the same directory and pages or nested layouts in its subdirectories will be wrapped by the layout.

import layoutExampleLayout from "$examples/layout/layout.jsx?sample";
import layoutExampleHome from "$examples/layout/page.jsx?sample";
import layoutExampleAbout from "$examples/layout/about.page.jsx?sample";

<SampleViewer filename="pages/layout.jsx" code={layoutExampleLayout} />
<SampleViewer filename="pages/page.jsx" code={layoutExampleHome} />
<SampleViewer
	filename="pages/about.page.jsx"
	code={layoutExampleAbout}
	url="/examples/layout"
	height="12em"
/>

### Thematic grouping

Sometimes you want pages that don't share a common URL prefix to share a layout. For this purpose you can use directory names that start with an underscore. They will not be part of the URL path. For example you could have a directory structure like this:

- `pages/`
  - `layout.jsx` (the root layout, common to all pages)
  - `_app/` (thematic group for most pages)
    - `layout.jsx` (common layout for most pages)
    - `page.jsx` (path: `/`)
    - `about.page.jsx` (path: `/about`)
    - `blog.page.jsx` (path: `/blog`)
  - `_admin` (thematic group for admin pages)
    - `layout.jsx` (common layout for admin pages)
    - `settings.page.tsx` (path: `/settings`)
    - `users.page.tsx` (path: `/users`)

## Data loading

Data fetching in React applications is mot trivial. There are many soltions of varying quality ranging from a simple `useEffect` hook to feature-packed libraries. Rakkas pages and layouts being plain React components, you're free to use any of those methods. But Rakkas offers a simple and straightforward solution that works both during server-side rendering as well as on the client:

If you export a `load` function from your page or layout module, Rakkas will call this function before rendering your component. If you return a promise, Rakkas will wait until it resolves. The `data` prop of the (resoled) return value will be passed to the component as `props.data`.

`load` may run either on the server or on the client: When the page is first loaded, the page will be rendered server-side so it will be called on the server and its return value will be serialized and sent to the client. But during client-side navigation, it will be called on the client-side without hitting the server. This means that there are some rules you have to follow:

- The code in `load` must be able to run both on the server and the browser; you should not call Node-only or browser-only APIs. In particular, `window` and `document` are not available.
- The returned `data` property must be serializable using [devalue](https://github.com/Rich-Harris/devalue). Check their documentation to see what's allowed.

> The load function is passed the following arguments:
> 1
>
> #### `url: URL`
>
> URL of the page being loaded. You can use it to access, for example, the query string with `url.search` or `url.searchParams`.
>
> ---
>
> #### `params: Record<string, string>`
>
> Path parameters for dynamic routes.
>
> ---
>
> #### `fetch: function`
>
> A function with a very similar API to the browser's [`fetch` function](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API). When `load` is called on the client, it really _is_ the browser's `fetch`. On the server, it is a special function that is designed to behave just like the client-side `fetch` as closely as possible. ⚠️ **You should only use this function for fetching data**. Using `XMLHttpRequest`, `axios`, or similar is not supported and will fail during server-side rendering. Using the global `fetch` function is also disallowed.
>
> ---
>
> #### `context: Record<string, string>` (only for layouts)
>
> We'll cover this one later.

There are three types of possible return values:

1. **A succesful result** is an object with a `data` property that will be passed to the page component as `props.data`, and optionally a `status` property which should be an integer between 200 and 299 (inclusive) that will be used as the HTTP status of the response when doing server-side rendering. Default is 200.
2. **An error result** is an object with an `error` property describing the error. We'll cover error handling more in depth below. For now all you should only know is that it has to have a `message` property. The return value may also have an optional `status` property which should be an integer between 400 and 599 (inclusive) that will be used as the HTTP status of the response when doing server-side rendering. Default is 500, indicating a server error. If your `load` function throws or returns a promise that rejects, it will be treated as if it returned an error 500.
3. **A redirection result** is an object that includes a `location` property which may be either a string or a URL object. A redirection result will abort the rendering of the current page and the user will be redirected to the specified location. The return value must also have a `status` property which should be an integer between 300 and 399 (inclusive) that will be used as the HTTP status of the redirection response when doing server-side rendering.

Here's a simple example of data loading that uses the free Pokéapi:

import fetchExample from "$examples/fetch/[pokemon].page.jsx?sample";

<SampleViewer url="/examples/fetch/pikachu" code={fetchExample} height="35em" />

> If you come from Next.js, `load` is similar to `getServerSideProps` and `getStaticProps`. But there are important differences: `getServerSideProps` will only run on the server but `load` may run either on the server or the client. So calling backend functions from `load` is not allowed, all communication must go through an API even during server-side rendering. If you're familiar with `SvelteKit`, it is very similar to how it handles data fetching.

### `definePage` and `defineLayout` functions

Defining and exporting a `load` function next to your page component has two drawbacks:

1. It interferes with React fast refresh which reloads your component without resetting its state when you change your code during development because a module should only export React components for it to work and `load` is not a React component.
2. In TypeScript, there's no good way to ensure type-safety between the `load` function and the component.

For these reasons, the recommended method for defining pages and layouts that need to load data is to use the `definePage` or `defineLayout` functions. They circumvent the first point by manually registering the page component to the React refresh system and the second point by allowing you to define strict types in TypeScript.

Here's a TypeScript reimplemenation of the Pokéapi demo:

import fetchDefinePageExample from "$examples/fetch-define-page/[pokemon].page.tsx?sample";

<SampleViewer
	url="/examples/fetch-define-page/pikachu"
	code={fetchDefinePageExample}
	height="35em"
/>

## Layout context

A Rakkas layout is not just a simple wrapper component, it also acts as data fetching middleware for nested layouts and pages. A layout's `load` function, unlike a page's, can return a `context` object which will be passed down to lower level layouts and pages. Both the `load` functions and the React components receive this as a prop. `context` objects returned from nested layouts are shallowly merged with the parent one. All context values must be serializable by `devalue`.

> ⚠️ There's no relation with the React context API and Rakkas's layout context system.

Let's say you have two pages, `/widget/[widgetId]/view` and `/widget/[widgetId]/edit` which views and edits a widget respectively. Both pages will need the contents of the widget. You can achieve this, without duplicating your code in both pages, by creating a layout `/widget/[widgetId]/layout.jsx` that fetches the widget data and passes it down to the pages using the `context` mechanism. You don't even have to define a component for your layout if it's only used for data fetching:

import contextExampleLayout from "$examples/widget/[widgetId]/layout.tsx?sample";
import contextExampleView from "$examples/widget/[widgetId]/view.page.tsx?sample";
import contextExampleEdit from "$examples/widget/[widgetId]/edit.page.tsx?sample";

<SampleViewer
	filename="pages/widget/[widgetId]/layout.tsx"
	code={contextExampleLayout}
/>
<SampleViewer
	filename="pages/widget/[widgetId]/view.page.tsx"
	code={contextExampleView}
/>
<SampleViewer
	filename="pages/widget/[widgetId]/edit.page.tsx"
	code={contextExampleEdit}
	url="/examples/widget/Foo/view"
	height="12em"
/>

### Root context and server-side customization hooks

The context passed to the outermost page or layout can be initialized **on the server-side** when the page is first served. You should export a `servePage` function that you may export from `src/server.js` (or `ts`):

import serverHook from "$examples/server.ts?sample";

<SampleViewer filename="src/server.ts" code={serverHook} />

Both `server.ts/.js` and the `servePage` export are optional. If not provided, the root context will be `{}`. The root context value can be updated on the client by calling the `setRootContext` function exported from `rakkasjs` module. The value will not be persisted on the server, you'll have to implement it yourself.

The root context can be used for session management.

## Reloading page/layout data

By default, Rakkas only calls the `load` function under these circumstances:

- When a page or layout is being rendered on the server side.
- When client-side navigation causes a page or layout change. Only the `load` functions of the page component and those of the newly mounted layout components will be called. If a layout stays mounted during navigation, it won't be reloaded.
- Only for pages, when the URL path or query string (`url.pathname` and `url.search`) changes. Layouts are not affected.
- Only during development, when a page or layout module is hot reloaded.

There are three methods for changing the reloading behavior:

### `getCacheKey` function

You can have a `getCacheKey` function in the object you pass to `definePage` or `defineLayout`. It is passed the same arguments as the `load` function except for `fetch`. Its return value can be anything that can be serialized into JSON. Rakkas will call it everytime it has to decide whether to call the `load` function and will only call it if the return value is different than the last time.

For example, you can prevent Rakkas from calling your page's `load` function only when the URL path changes and not when the query string changes like this:

import getCacheKeyPage from "$examples/get-cache-key/page.tsx?sample";

<SampleViewer code={getCacheKeyPage} />

Or you can force Rakkas to call your layout's `load` function when the URL path changes like this:

import getCacheKeyLayout from "$examples/get-cache-key/layout.tsx?sample";

<SampleViewer code={getCacheKeyLayout} />

### `reload` function

Page and layout components are passed a `reload` prop which you can use to manually force Rakkas to call its `load` function and rerender it:

import reloadExample from "$examples/reload/page.tsx?sample";

<SampleViewer url="/examples/reload" code={reloadExample} />

### `useReload` custom hook

Page and layout components are passed a `useReload` function which is a React custom hook used to force a reload under certain conditions:

import useReloadExample from "$examples/reload/use-reload.page.tsx?sample";

<SampleViewer url="/examples/reload/use-reload" code={useReloadExample} />

## Error handling

If a layout or page `load` function returns an error or throws, layouts and pages further nested in the hierarchy will not be called and the innermost layout or page that reported itself as an error handler is rendered with an `error` prop passed to its component. Layouts are assumed to be able to handle errors while pages are assumed not to be able to handle them. You can override this by passing true or false to `options.canHandleErrors` to `definePage` or `defineLayout`. 404 errors are handled in the same way, as if a page's load function returned an error.

import errorExampleLayout from "$examples/error-handling/layout.tsx?sample";
import errorExamplePage from "$examples/error-handling/page.tsx?sample";

<SampleViewer code={errorExampleLayout} />
<SampleViewer url="/examples/error-handling" code={errorExamplePage} />

## API routes

You can build your backend API with Rakkas using endpoints and middlewares that are analogous to pages and layouts respectively.

In most Node.js frameworks (like Express) you handle HTTP requests by manipulating request and response objects. These are not available in every serverless environment Rakkas aims to support. So we use an even simpler model: You get a plain object that represents the request, and you return a plain object that represents the response.

#### `RakkasRequest`

Rakkas's request object `RakkasRequest` has the following props:

| Name    | Type                                                | Description                      |
| ------- | --------------------------------------------------- | -------------------------------- |
| url     | `URL`                                               | Request URL                      |
| method  | `string`                                            | HTTP method                      |
| headers | `Headers`                                           | HTTP headers                     |
| params  | `Record<string, string>`                            | Path parameters                  |
| context | `Record<string, any>`                               | See below                        |
| type    | See below                                           | Content-type of the request body |
| body    | `Uint8Array`, `string`, `any`, or `URLSearchParams` | Request body                     |

The `type` prop can be either `"empty"`, `"binary"`, `"text"`, `"form-data"`, or `"json"` depending on the request's body and `Content-Type` header:

| Type         | Type of `body`    | Description                                                                                      |
| ------------ | ----------------- | ------------------------------------------------------------------------------------------------ |
| "empty"      | `undefined`       | The request body is empty                                                                        |
| "text"       | `string`          | `Content-Type` starts with `text/`, body has been parsed as a string                             |
| "form-data"¹ | `URLSearchParams` | `Content-Type` is `application/x-www-form-urlencoded`, body has been parsed as `URLSearchParams` |
| "json"       | `unknown`         | `Content-Type` is `application/json` or ends with `+json`, body has been parsed as JSON          |
| "binary"     | `Uint8Array`      | None of the above, body has been parsed as binary                                                |

¹ Rakkas will support parsing `multipart/form-data` before version 1.0.

#### `RakkasResponse`

Rakkas's request object `RakkasResponse` has the following props, all optional:

| Name    | Type      | Description               |
| ------- | --------- | ------------------------- |
| status  | `number`  | HTTP status, defaults 200 |
| headers | See below | Response headers          |
| body    | See below | Response body             |

The `headers` property can either be a name value dictionary or an array of name value pairs. The `body` will be empty if it's null or undefined, sent as binary if it is `Uint8Array`, as text if it's a string. It will be JSON stringified if it is something else.

### Endpoints

An endpoint is a module in `src/api` directory, named `endpoint.js` or anything that matches `*.endpoint.js` (or `ts`, or any other extension included in the `apiExtensions` configuration option). It exports method handlers, functions that correspond to HTTP methods like `get`, `post`, `put` etc. `DELETE` method is handled by the `del` function because `delete` is a reserved word in JavaScript.

A method handler is just a function that takes a `RakkasRequest` and returns a `RakkasResponse`, possibly asynchronously.

Routing works similarly to pages:

| Module name                          | URL path                                                           |
| ------------------------------------ | ------------------------------------------------------------------ |
| `src/api/endpoint.jsx`               | `/api/`                                                            |
| `src/api/user.endpoint.jsx`          | `/api/user`                                                        |
| `src/api/user/endpoint.jsx`          | also `/api/user`                                                   |
| `src/api/user/[userId].endpoint.jsx` | `/api/user/[userId]` where `[userId]` is a dynamic route parameter |

As an alternative, or in addition to exporting individual method handlers you can default export a function to handle all methods. Specific method handlers have priority.

### Middleware functions

If you default export a function from a file named `middleware.js` (or `ts`, or any other extension included in the `apiExtensions` configuration option) in the `src/api` directory or in one of its subdirectories, you can intercept requests that would be otherwise handled by endpoint handlers in that directory or in one of its subdirectories. Like layouts, middleware functions can be nested and thematically grouped.

A middleware function receives a `RakkasRequest` just like an endpoint handler and is expected to return a `RakkasRespone` (or a promise of one) just like an endpoint. But it receives a second parameter, a `next()` function which calls the next middleware function or endpoint handler in the hierarchy. You can pass `next()` a modified request and return a modified response or you can return a response without even calling `next`.

The `context` property is a way to pass data from a middleware function to nested middleware functions or endpoint handlers. For example, you can create a cookie parsing middleware like this:

import middlewareExample from "$examples/middleware.ts?sample";

<SampleViewer code={middlewareExample} />

And you can acces the cookies like this:

import endpointExample from "$examples/endpoint.ts?sample";

<SampleViewer code={endpointExample} />

### Fetching data from downstream servers

A server-side `fetch` implementation is available to middleware and endpoint modules for fetching data from downstream servers.
